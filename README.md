# Стажировка 2021. Mobile BigData, тестовое задание

## Суть задания

Необходимо разработать сервис, который будет получать данные по уровню сигнала от пользователей и отображать в веб-приложении на карте в тайлах S2 уровня 15 (https://s2geometry.io/)  две агрегатные метрики — средний уровень сигнала на тайл и количество уникальных пользователей в тайле.

## Описание задания

**Сбор данных**

В сервис постоянно поступают данные от разных клиентов в формате:

| **Аргумент** | **Тип** | **Описание**           | **Валидные значения**                                                            |
| ---------------- | ----------- | -------------------------- | ------------------------------------------------------------------------------------ |
| lat              | float64     | широта                     | [-90;90]                                                                             |
| lon              | float64     | долгота                    | [-180;180]                                                                           |
| user_id          | string      | идентификатор пользователя | любой корректный UUID в строковом представлении (https://ru.wikipedia.org/wiki/UUID) |
| signal           | float64     | уровень сигнала            | [0;100]                                                                              |



> **Географические координаты поступают в формате десятичных градусов** **—** **https://en.wikipedia.org/wiki/Decimal_degrees**

**Метод:** POST
URL: [http://127.0.0.1:8080/collector](http://127.0.0.1:8080/collector)
Content-Type: application/json

Пример запроса:

    {
      "lat": 59.9355,
      "lon": 30.325623,
      "user_id": "98ea80cf-268a-474f-9ebb-5cc49b55365b",
      "signal": 20.68
    }

**Ответ:**
В случае корректных данных:  HTTP 200
В случае некорректных данных или ошибки в формате:  HTTP 400
Для других ошибок:  HTTP 500

Данные хранятся на диске или в key-value хранилище LevelDB (https://github.com/google/leveldb) в формате, удобном для отдачи агрегатных метрик по тайлам S2 уровня 15. При перезапуске сервису должны быть доступны те же данные, которые были доступны до перезапуска.


> **Под тайлом S2 подразумевается s2 cell (https://s2geometry.io/devguide/s2cell_hierarchy.html).**

**Отображение на карте**
В интерфейсе веб-приложения ([http://127.0.0.1:8080/map/](http://127.0.0.1:8080/map/)) отображается карта с элементами управления отображением данных. Это стандартные элементы управления картой, а также переключатель отображаемой метрики. На **видимой** части карты должны отображаться границы тайлов s2 **уровня 15** и выбранная метрика. Как отображать метрику на карте, решите самостоятельно. Например используйте подписи тайлов, или heatmap в цвете тайла. 
Пользователь может перемещать видимую часть карты, а также менять отображаемую метрику.

![Пример отображения границ тайлов S2](https://paper-attachments.dropbox.com/s_63740D5E0E67B2F60286C6A062CF05A7315801AE01A950EC4D17109A4657B9A8_1621583310240_Screenshot+2021-05-21+at+10.48.25.png)


Для получения данных по тайлам S2 веб-приложение запрашивает их в следующем формате:

| **Аргумент** | **Тип**   | **Описание**                                                                              | **Валидные значения** |
| ---------------- | ------------- | --------------------------------------------------------------------------------------------- | ------------------------- |
| area             | [2]coordinate | видимая часть карты — координаты юго-западного и северо-восточного углов в формате coordinate | —                         |

Описание структуры coordinate:

| **Аргумент** | **Тип** | **Описание** | **Валидные значения** |
| ---------------- | ----------- | ---------------- | ------------------------- |
| lat              | float64     | широта           | [-90;90]                  |
| lon              | float64     | долгота          | [-180;180]                |


**Метод:** POST
URL: [http://127.0.0.1:8080/data](http://127.0.0.1:8080/data)
Content-Type: application/json

Пример запроса:

    {
      "area": [
        {
          "lat": 49.88960818299432,
          "lon": 30.15311209124958
        },
        {
          "lat": 60.08872995765761,
          "lon": 32.647798314371222
        }
      ]
    }

**Ответ:** 
В ответ бэкенд возвращает массив, каждый элемент которого представляет из себя координаты для тайла S2 уровня 15, средний уровень сигнала в тайле и количество уникальных пользователей в тайле.


> **Если для тайла нет данных, то он не возвращается в ответе и не должен быть отображён на карте.**

Content-Type: application/json
Формат:  []data_reply

Описание структуры data_reply:

| **Аргумент** | **Тип**  | **Описание**                                                                               |
| ---------------- | ------------ | ---------------------------------------------------------------------------------------------- |
| s2_id            | uint64       | идентификатор тайла s2 в десятичном формате (s2 cell ID)                                       |
| s2_coordinates   | []coordinate | массив координат тайла S2 (каждая координата — угол полигона) **в порядке по часовой стрелке** |
| signal_avg       | float64      | среднее значение уровня сигнала для тайла S2                                                   |
| uniq_users       | uint64       | количество уникальных пользователей для тайла S2                                               |

Пример ответа:

    [
      {
        "s2_id": 4671715362205597696,
        "s2_coordinates": [
          {
            "lat": 50.93601081479124,
            "lon": 31.32189934344325
          },
          {
            "lat": 50.93811797742182,
            "lon": 31.324520111410386
          },
          {
            "lat": 50.93701796757542,
            "lon": 31.32821381101612
          },
          {
            "lat": 50.93491095327657,
            "lon": 31.325592868267584
          }
        ],
        "uniq_users": 184,
        "signal_avg": 10.6
      },
      {
        "s2_id": 5086306770729566208,
        "s2_coordinates": [
          {
            "lat": 59.9359333477993,
            "lon": 30.322696609107933
          },
          {
            "lat": 59.93831618971072,
            "lon": 30.325911332586188
          },
          {
            "lat": 59.93710813132604,
            "lon": 30.330674284103665
          },
          {
            "lat": 59.93472546343711,
            "lon": 30.32745926011543
          }
        ],
        "uniq_users": 184,
        "signal_avg": 1.68
      }
    ]

В случае корректных данных:  HTTP 200
В случае некорректных данных или ошибки в формате:  HTTP 400
Для других ошибок:  HTTP 500


## Справка по S2 geometry

Обзор S2 geometry: https://s2geometry.io/about/overview.
Для работы с S2 **необходимо** использовать пакет s2: https://pkg.go.dev/github.com/golang/geo/s2.
В тестовом задании под тайлом S2 подразумевается S2 cell.
В ходе выполнения тестового задания вам потребуется реализовать:
- преобразование точки (широта, долгота) с десятичными градусами в тайл S2 уровня 15;
- вычисление массива тайлов S2 уровня 15, покрывающих определённую область (четырёхугольник) на карте;
- вычисление вершин границ тайла S2 уровня 15 в десятичных координатах (4 вершины, каждая точка задана широтой и долготой).

Ниже представлен краткий справочник по API этой библиотеки. Все перечисленные функции и структуры пригодятся для реализаций этих операций.


    type CellID uint64

Уникальный идентификатор тайла S2.


    type LatLng struct

Точка на единичной сфере в виде пары углов `Angle`.


    type Angle float64

Угол.


    func (a Angle) Degrees() float64

Представление угла в десятичных градусах.


    func LatLngFromDegrees(lat, lng float64) LatLng

Конструктор `LatLng` из координат в десятичных градусах.


    func CellIDFromLatLng(ll LatLng) CellID

Конструктор `CellID` из точки `LatLng`. Из точки получается тайл с уровнем 30.


    func (ci CellID) Parent(level int) CellID

Вычисляет родительский тайл более высокого уровня. Можно использовать, например, для вычисления тайла уровня 15 из тайла уровня 30.


    type Cell struct

Тайл S2. Почти то же самое, что и `CellID`, но обладает дополнительными методами.


    func CellFromCellID(id CellID) Cell

Конструктор `Cell` из `CellID`.


    type Point struct

Точка на единичной сфере в виде нормализованного трёхмерного вектора.


    func PointFromLatLng(ll LatLng) Point

Преобразование `LatLng` в  `Point`.


    func LatLngFromPoint(p Point) LatLng

Преобразование  `Point` в `LatLng`.


    type Loop struct

Многоугольник на сферической поверхности. **Обратите внимание:** если вершины расположены по часовой стрелке, то площадью такого многоугольника будет считаться внешнее пространство (вся карта с вырезанным прямоугольником), если против, то площадью будет область внутри многоугольника.


    func LoopFromPoints(pts []Point) *Loop 

Конструктор `Loop`.


    func (l *Loop) Invert() 

Меняет порядок вершин в многоугольнике. Полезно использовать после `LoopFromPoints`, если вершины в конструктор были переданы в порядке по часовой стрелке.


    func (l *Loop) Vertices() []Point

Вершины многоугольника.


    type Polygon struct

Последовательность `Loop`.


    func (p *Polygon) Loop(k int) *Loop

`Loop` из `Polygon` по индексу.


    func PolygonFromCell(cell Cell) *Polygon

Конструктор `Polygon` из `Cell`. Такой `Polygon` **обязательно содержит только один** `Loop` с индексом 0.


    type CellUnion []CellID

Массив из `CellID`.


    type RegionCoverer struct

`RegionCoverer` аппроксимирует область на `CellUnion`.  То есть позволяет вычислять тайлы S2, покрывающие некоторую область на карте. Содержит настройки аппроксимации `MinLevel`, `MaxLevel` и `MaxCells`.


    func (rc *RegionCoverer) Covering(region Region) CellUnion

Метод аппроксимации (покрытия) некоторой области на тайлы S2.  `Cell`, `Loop`, `Polygon` являются реализациями интерфейса `Region`.


## Требования к сервису

- Данные поступают постоянно, порядок — сотни запросов в секунду.
- Сервис обеспечивает быстрый отклик на запросы агрегации по тайлам — обратите внимание на UX-опыт пользователя.
- При каждом запросе с фронта должны отдаваться актуальные данные.
- Данные хранятся на диске или в key-value хранилище (LevelDB).
- Разрешены вероятностные алгоритмы подсчёта уникальных пользователей со ошибкой в 5-10%. При значениях уникальных пользователей меньше < 500, допускается ошибка > 10%. То есть алгоритм должен корректно работать прежде всего для количества уникальных пользователей > 500.


## Требования к коду

Бэкенд:
- язык программирования — Go;
- версия Go — 1.16.4;
- для написания http-сервера можно использовать стандартный пакет http или любые популярные http-фреймворки;
- для работы с S2 необходимо использовать библиотеку s2 (https://pkg.go.dev/github.com/golang/geo/s2) ;
- для работы с UUID можно использовать  https://pkg.go.dev/github.com/google/uuid или другой похожий пакет;
- для работы с LevelDB можно использовать любой клиент для Go, например https://github.com/syndtr/goleveldb;
- не рекомендуется использовать другие пакеты, кроме упомянутых выше, стандартных и пакетов, не влияющих на логику сервиса (например, logrus и rice не влияют на логику сервиса, значит, их можно использовать).

Фронтенд:
- язык программирования — JavaScript;
- в качестве http-клиента можно использовать стандартный fetch или библиотеку axios; (https://github.com/axios/axios);
- можно использовать D3.js (https://d3js.org/);
- можно использовать  Google Fonts (https://fonts.google.com/);
- можно использовать JavaScript API карт: Yandex, Google, 2GIS или MapBox;
- веб-приложение должно работать в Google Chrome >= 90, другие версии и браузеры поддерживать необязательно;
- иные библиотеки, кроме упомянутых выше и стандартного браузерного API, использовать не рекомендуется.


## Формат ответа на тестовое задание

Необходимо предоставить ссылку на репозиторий с кодом и файлом README.md, в котором будет упомянуто:
- что получилось реализовать;
- что не получилось реализовать;
- высокоуровневое описание реализации.

Также обязательно наличие `Dockerfile`, с помощью которого можно будет запустить приложение. Будут применяться следующие команды запуска:

     docker build -t mbd-internship .
     docker run -p 8080:8080 mbd-internship

При проверке будут использованы следующие эндпоинты:

| [http://127.0.0.1:8080/collector](http://127.0.0.1:8080/collector) | сбор данных                                |
| ------------------------------------------------------------------ | ------------------------------------------ |
| [http://127.0.0.1:8080/data](http://127.0.0.1:8080/data)           | агрегация данных по тайлам для отображения |
| [http://127.0.0.1:8080/map/](http://127.0.0.1:8080/map/)           | веб-приложение с картой                    |